## Objetivos

- [ ] Ejecutar un fichero js en navegador, quoakka.js y terminal ðŸ“… 2023-02-16 #fundamentosjs
- [ ] Aprender a  debuggear ðŸ“… 2023-02-20 #fundamentosjs


## Donde se ejecuta JavaScript

- Mediante etiquetas script
- inline
- En un fichero aparte
- Mediante CLI 
```bash
node script.js`
```

Ejemplo:

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Document</title>
	</head>
	<body onload="alert('hola mundo')">
		<script>
			alert('Hola mundo2');
		</script>
		<script src="script.js"></script>
	</body>
</html>
```


## Consola

-  Probar con Quokka y  node
- Ver console.log, console.warn... variables, texto, operaciones matemÃ¡ticas


## Nombre  de  las variables
	
Las variables se escriben en camelCase:
- **firstName** vs first_name (Ruby)

En mayÃºsculas los objetos o constantes. 
- **let Person = {};**
- **const PI=3.141521;**

Pero es una costumbre generalizada no un  requerimiento del lenguaje

Las variables no pueden empezar por nÃºmero:
let 3years ---> Error, nos avisa de  que no  se  puede nombrar asÃ­!!!
Estos errores aparecen en la consola, aunque no lo hagamos nosotros de forma explÃ­cita.


- Guardar en dos variables el nombre de mis 2 primeros amigos. Mostrarlo por consola
	-Comprobar  que tienen **riqueza semÃ¡ntica**. Mejor "primerAmigo" que  amigo1 por  ej.


## Variables

- Primitivas
	```js
		let nombre = "Pepe";
		let edad = 25;
		let estÃ¡Casado = false;
	```
- Objetos
```js
	let Yo = {
		nombre: "Pepe",
		edad: 25,
		casado: false
	}
```

## Tipos de datos primitivos
- **Number**
	- Con o sin  decimales (no hay varios tipos como en otros lenguajes)
- **String**
- **Boolean**
- **Undefined**: valor de una variable que todavÃ­a no se ha definido (declarada, sin  definir)
	- PodrÃ­amos pensar en undefined como "valor vacÃ­o"
- **Null**: lo mismo,  pero se usa en otras circunstancias.
- **Symbol**
	- Introducido  en ES2015
	- Variable  con valor Ãºnico y que no se puede cambiar
	- Lo veremos tambiÃ©n mÃ¡s adelante
- **BigInt **
	- Introducido en ES2020
	- Para enteros  mÃ¡s grandes que los que soporta el tipo  Number


JS  tiene **tipado dinÃ¡mico**, como PHP, asÃ­ que os resultarÃ¡ sencillo.
	- Es el valor el que tiene el tipo, no la variable
	- Las variables almacenan el valor, que es el que tiene el tipo.


- Usar operador **typeof** para ver los tipos
- Comentarios en JS 
	- Usar CTRL + Mays + 7 en VS Code
- Usar extensiÃ³n para console.log


## DeclaraciÃ³n variables en JS
- Mediante let, const y  var
- Ojo si no  se utiliza ninguna se guarda en  el **global scope**


## Operadores
```js
const edadPepe  = 2022 - aÃ±oNacimientoPepe
```


Â¿Y si  tenemos que calcular mÃ¡s de una edad?
Refactorizar cÃ³digo usando una funciÃ³n, lo veremos mÃ¡s adelante. De momento:
```js
const aÃ±oActual = 2022
const edadPepe = aÃ±oActual - aÃ±oNacimientoPepe
const edadMarta = aÃ±oActual - aÃ±oNacimientoMarta
```

Comparar quien  es mayor y si devuelve verdadero o falso


##  Desafio 1

Pedro y  Lucas quieren comparar su Ã­ndice de masa corporal, que se calcula mediante  la fÃ³rmula IMC =  peso / (altura x altura) (masa en kg y altura en metros).

1. Guarda el  peso  y la altura de Pedro y Lucas  en  variables
2. Calcula el IMC de ambos.
3. Guarda en una variable booleana llamada PedroMayorIMC el resultado.

TEST DATA 1: Pedro pesa 78 kg y mide 1.69.  Lucas pesa 92 kg y mide 1.95.
TEST DATA 2: Pedro pesa 95 kg y mide 1.88.  Lucas pesa 85 kg y mide 1.76.


## Comentarios en JavaScript

- Forma tradicional  (con  comillas dobles o simples)
```js
const nombre = "Pepe";
const trabajo = "InformÃ¡tico";
const aÃ±oNacimiento  = 1990;
const aÃ±oActual = 2022;
const saludo = "Hola, me llamo "  + nombre + " y  trabajo de "  + trabajo + " y tengo " + (aÃ±oActual - aÃ±oNacimiento) + " aÃ±os"
```

- Otra opciÃ³n mÃ¡s actual es  usar **template literals** (con comillas  invertidas):
```js
const saludo = `Hola, me lllamo ${nombre} y  trabajo de ${trabajo} y tengo ${aÃ±oActual  -  aÃ±oNacimiento} aÃ±os.`
```

-  Ventajas:
	- Lectura mÃ¡s sencilla
	- Multilinea
	- Hay quien utiliza siempre  este mÃ©todo (haya o  no variables)

```js
console.log(`Ha ocurrido un error`);
console.log ("cadena con \n\
			 varias  \n\
			 lÃ­neas");
console.log(`cadena con
             varias
            lÃ­neas`);
```

## Estructuras de control
###  if / else
```js
const mayoriaEdad = 18;
const edad = 17;
const esMayorDeEdad = edad >=18;
if (esMayorDeEdad) {
   console.log(`Puedes beber cerveza y conducir;`);
} else {
   console.log(`Puedes tomar zumos y viajar  en bus`);
}
```


## DesafÃ­o 2

Usa el  Desafio 1 sobre IMC que acabamos de hacer y aÃ±ade  lo siguiente:

  1. Muestra por consola un texto indicando quien tiene un Ã­ndice de masa corporal mayor.
  2. Incluye los valores de IMC en el texto.

Ayuda: usa sentencia if/else y string literal



## ConversiÃ³n entre tipos
- **Type conversion**: convertimos un tipo a otro
- **Type coercion**: JS hace una conversiÃ³n implÃ­cita por nosotros

###  Ejemplos

- El  operador + sirve tanto para concatenar textos como para sumar

```js
/* si aÃ±oNacimiento se recogiera mediante un formulario, serÃ­a un string */
const aÃ±oNacimiento = "1990";
console.log(`Fuiste mayor de edad en el aÃ±o ${aÃ±oNacimiento + 18}`);

```

- Podemos corregir el ejemplo anterior con una conversiÃ³n de tipos utilizando *Number*

```js
const aÃ±oNacimiento = "1990";
console.log(`Fuiste mayor de edad en el aÃ±o ${Number(aÃ±oNacimiento) + 18}`);
// observa que Number no cambia el tipo de dato de la variable
console.log(aÃ±oNacimiento, Number(aÃ±oNacimiento))
```
- Â¿QuÃ© pasa si  intentamos convertir un dato que no es nÃºmero?
```js
console.log(Number('Pedro'));
// nos  darÃ¡ NaN que es un  nÃºmero en sÃ­ mismo:
console.log(typeof NaN);
```

- Otra opciÃ³n es convertir a String
```js
console.log(String(23), 23);
```

- Type coercion:
	- Cuando  recogemos valores de un formulario lo normal  es que vengan como strings
	- Por eso a veces (+) pueden arrojar resultados inesperados
	- Hay muchos "enemigos" del type coercion ya que es propenso a errores.
```js
console.log ('Tengo ' + 28 + " aÃ±os");
console.log('23' - '10' -  3);
console.log('23' / '2');


const aÃ±oNacimiento = 1990;
console.log(`Fuiste mayor de edad en el aÃ±o ${aÃ±oNacimiento + 18}`);


const aÃ±oActual  = "2022";
const  edad = "25";
console.log(`Naciste en el aÃ±o ${aÃ±oActual - edad}`)
``````
- Hay 5 tipos que se convierten a False: 0, '', undefined, null y NaN
```js
console.log(Boolean(0));
console.log(Boolean('');
console.log(Boolean('pepe'));
...
```
- Las  conversiones a Boolean normalmente se hacen de forma implÃ­cita (type coercion):
	- En operadores lÃ³gicos
	- En contextos de tipo lÃ³gico, por ejemplo la condiciÃ³n de un bucle if:
```js
const dinero = 0;
if (dinero) {
   console.log(`Â¡Vamos al cine!`);
} else  {
   console.log(`BÃºscate  un trabajo`);
}
```

### Igualdad e igualdad  estricta
- La  igualdad  estricta ====  verifica que el tipo coincida
- La igualdad no estricta  == realiza type coercion

```js
const edad = prompt("Â¿CuÃ¡l es tu edad");
console.log (edad, typeof edad);
if (edad === 18) console.log(`Ya puedes beber cerveza`);
else if (edad === 17) console.log(`Te falta poco para poder beber cerveza`);
else if ....
else
```
Observa que en el cÃ³digo anterior no  ponemos llaves en los if-else al ser de una sola lÃ­nea


##  ConcatenaciÃ³n de booleanos

- Mediante los operadores **&&** y **||**

```js
const nombre = 'Pepe';
const edad = 19;
const esMayorDeEdad =  edad>18;
const tieneCarnetDeConducir = true;

if (esMayorDeEdad && tieneCarnetDeConducir)   {
	console.log(`${nombre}  puede conducir`)
}
```
- A  veces es Ãºtil tambiÃ©n el operador de negaciÃ³n: **!** 
```js
const nombre = 'Pepe';
const  edad = 19;
const esMayorDeEdad =  edad>18;
const tieneCarnetDeConducir = true;
const estaCansado = true
if (esMayorDeEdad && tieneCarnetDeConducir  && !estaCansado)   {
	console.log(`${nombre}  puede conducir`)
}
```


## DesafÃ­o  3

Tenemos dos equipos  de gimnastas,  EspaÃ±a y Francia. Deben competir entre  ellos un total de 3  veces.
El  que  tenga la mayor puntuaciÃ³n media gana el trofeo.

1. Calcula la puntuaciÃ³n  media de  cada equipo teniendo en cuenta  los datos proporcionados.

2. Compara  la  puntuaciÃ³n media de cada  equipo para determinar el ganador y muÃ©stralo por  consola. No  olvides que puede haber  un  empate  y  Â¡los dos  serÃ¡n campeones! 

3. BONUS: Incluimos un requerimiento de  una puntuaciÃ³n  mÃ­nima de  100. Con esta regla, un equipo  ganarÃ¡ solo si ademÃ¡s de tener mayor puntuaciÃ³n  que el  otro equipo tiene al menos 100  puntos.  

Datos: EspaÃ±a: 96, 108 y 89. Francia 88, 91 y 110.

Datos BONUS: EspaÃ±a 97, 112 y 101.  Francia 109, 95 y 123


## Switch
- Prueba a hacer un programa que nos de la comida que vamos a comer cada dÃ­a en funciÃ³n del dÃ­a actual:
	- Lunes: verdura
	- Martes: pasta
	- MiÃ©rcoles: legumbre
	- Jueves:  verdura
	- Viernes: legumbre
	- SÃ¡bado:  libre
	- Domingo: libre


- Â¿CÃ³mo prefieres  hacerlo, con if-else o con switch?
```js
switch(_expression_) {  
 case _x_:  
 _// code block_ break;  
 case _y_:  
 _// code block_ break;  
 default:  
 // _code block_  
}
```
- Es mÃ¡s legible con switch-case, aunque mÃ¡s largos
- Normalmente hay  preferencia por if-else, pero este es un buen ejemplo para usar una sentencia switch
- Los "cases" si son textos, pueden ser fuente de errores, es bueno definir constantes

- Opciones:
	- Obtener de forma dinÃ¡mica el dÃ­a:
```js
const d = new Date(); 
const weekDay = d.getDay();
```


## Condicional mediante operador ternario
- Se evalÃºa una condiciÃ³n  (? y se separa el  if-else con :)
	- El *else* es obligatorio
```js
const edad = 20;
age >=18 ? console.log('Puedes beber cerveza') : console.log('Puedes beber agua');
```

- Se suele usar mucho  para asignaciÃ³n de variables:
	- Observa que con un  if-else serÃ­a mucho mÃ¡s  largo,
```js
const drink = age>=18 ? 'cerveza': 'agua';
console.log(`Puedes beber ${drink}`)

// o combinando, pero es menos legible:
console.log(`Puedes beber ${age >= 18 ? 'cerveza' : 'agua'}`)
```

```js
let drink;
if  (edad>=18)  {
	drink = 'wine';
} else  {
  drink = 'water';
}
```

## Desafio 4

DiseÃ±as  una  tienda virtual y  quieres calcular  el coste de asegurar la mercancÃ­a de envÃ­o.
Si el valor de la  mercancÃ­a  va entre 50 y 300â‚¬,  el  coste del seguro es un  15%.  Si el  valor es diferente, el coste  del  envÃ­o es un 20%.

1. Calcula el  importe del seguro dependiendo del  coste de la mercancia.  Puedes  crear una variable llamada valorProducto. No  debes usar una estructura if/else (la puedes  usar si te  ayuda, pero luego debes convertirla  a un  operador ternario).

2. Muestra por  consola  el valor  del producto, del seguro y el total. 

TEST DATA: Valor del producto 275, 40 and 430

```js
const valorProducto = 275
const impuesto =
	valorProducto > 50 && valorProducto < 300
	? (valorProducto * 15) / 100
	: (valorProducto * 20) / 100
const total = valorProducto + impuesto
console.log(
`Valor producto: ${valorProducto}, impuesto ${impuesto}, total: ${total}`
)
```

```js
const valorProducto = 275
let impuesto
if (valorProducto > 50 && valorProducto < 300) {
	impuesto = (valorProducto * 15) / 100
} else {
	impuesto = (valorProducto * 20) / 100
}
const total = valorProducto + impuesto
console.log(
`Valor producto: ${valorProducto}, impuesto ${impuesto}, total: ${total}`
)
```



## Strict mode
Se activa  escribiendo 
```js
// debe ser la primera lÃ­nea del script
'use  strict'; 
```

Nos puede evitar ciertos errores programando, compara el siguiente  cÃ³digo activando el uso estricto o no:

```js
let tieneCarnetDeConducir = false;
const aprobadoExamenConducir = true;
if (aprobadoExamenConducir)  tieneCarneDeConducir = true;
if (tieneCarnetDeConducir) console.log('Puede conducir!')
```

Otros ejemplos:
```js
// posibles  palabras reservadas en un futuro para el lenguaje.
const interface = 'carnet';
const private = true;
```


##  Funciones

Se definen:
```js
function saludar () {
	console.log ('Hola!');
}
function saludarConNombre (nombre) {
	console.log (`Hola! ${nombre}`);
}
```
Se invocan llamando a  la funciÃ³n:

```js
saludar();
/* reusamos el cÃ³digo de la funciÃ³n porque la ejecutamos dos veces */
saludar();
saludarConNombrer('pepe');
```

Las funciones pueden retornar un valor:

```js
function hacerZumo (naranjas, manzanas) {
	console.log(`Naranjas: ${naranjas}, manzanas:  ${manzanas} `)
  const zumo = `Zumo con ${naranjas} naranjas y ${manzanas}  manzanas.`
  return zumo;
}

const zumoDeManzana = hacerZumo (0,5);
console.log(zumoDeManzana);
console.log(hacerZumo(0,5));
```

No  harÃ­a  falta guardar el resultado de la funciÃ³n  en una variable, podrÃ­amos mostrar directamente la salida. 
Gracias a los parÃ¡metros podemos ejecutar la funciÃ³n  con diferentes valores.

- DeclaraciÃ³n de funciones

	```js
	function calcularEdad (aÃ±oNacimiento)  {
		return 2022 - aÃ±oNacimiento;
	}
	const edad1 = calcularEdad(1990);
	```

- Almacenamiento en una variable, usando una funciÃ³n  anÃ³nima. Es una expresiÃ³n de funciÃ³n (no una  declaraciÃ³n como antes) y **tiene  que retornar algo, para que  podamos guardarlo en una variable**.
	```js
	const calcularEdad = function (aÃ±oNacimiento)  {
		return 2022 - aÃ±oNacimiento;
	}
	```

En el primer  caso, se puede llamar a la funciÃ³n antes de declararla.  En el segundo caso no. Esto es debido a una cosa llamada **hoisting**, que veremos mÃ¡s adelante.

Usar uno u otro tipo es cuestiÃ³n de preferencias personales. Yo personalmente prefiero guardar todo en variables.

Hay un tercer tipo  que se aÃ±adiÃ³ en ES6 y es "mÃ¡s rÃ¡pida de escribir" ya que nos ahorramos las llaves y  el return (al ser una sola lÃ­nea):

- Funciones flecha (arrow functions):
	```js
	const calcularEdad = aÃ±oNacimmiento => 2022 - aÃ±oNacimiento;
	```

Ejercicio:
-  Crea una funciÃ³n  flecha que calcule los aÃ±os para la jubilaciÃ³n.

```js

const calcularAÃ±osJubilacion = aÃ±oNacimiento => {
	const edadActual = 2022 - aÃ±oNacimiento;
  const aÃ±osJubilacion = 67 - edadActual;
	return aÃ±osJubilacion;
}
```

Podemos probar a aÃ±adir algÃºn  otro parÃ¡metro y entonces los parÃ©ntesis serÃ¡n necesarios en la lista de argumentos de la funciÃ³n.
Es importante anotar que las funciones flecha no tienen acceso a **this** o no pueden utilizar **yield** y  otras cosas... pero no nos  debe preocupar, se verÃ¡  mÃ¡s adelante.


## Funciones que llaman  otras funciones

```js
function cortarPiezas (fruta) {
	return fruta*4;
}

function hacerZumo (naranjas, manzanas) {
	const  piezasNaranjas = cortarPiezas(naranjas);
	const piezasManzanas = cortarPiezas(manzanas); 
  // mejor con una funciÃ³n  que piezasManzanas =  manzanas+4, DRY!
  const zumo = `Zumo con ${piezasNaranjas} piezas de naranjas y ${piezasManzanas} piezas de manzanas.`
  return zumo;
}

const zumoDeManzana = hacerZumo (0,5);
console.log(zumoDeManzana);
```

## Arrays
Es una forma de almacenar variables de forma  mÃ¡s compacta:

```js
const amigo1="pepe";
const amigo2="juan";
const amigo3="lucas";
const amigos = ["pepe", "juan", "lucas"];
const amigos = new Array("pepe", "juan", "lucas"),
console.log(amigos, amigos[0], `total  de amigos: ${amigos.length}`);
```

Se pueden modificar valores:
```js
const amigos[2]="alfredo";
console.log(amigos);
```

Â¡Ojo!, ***const*** mantiene la direcciÃ³n  de  memoria,  los datos pueden  cambiar, no es como  los datos primitivos. Lo siguiente si darÃ­a error:

```js
amigos = ["pedro"];
```

Podemos  tener datos de tipo diverso:
```js
const nombre='Fernando';
const fernando = [nombre, 'MartÃ­nez', 2022 - 1990, 'mecÃ¡nico', amigos];
console.log(fernando);
```


## Ejercicio

Crear un array  de edades en funciÃ³n  de los siguientes datos:

```js
const calcularEdad = aÃ±oNacimiento => 2022 - aÃ±oNacimiento;
const aÃ±osNacimiento =  [1990,  1985, 2002, 1998];
```

Opciones:
```js
const edad1 = calcularEdad(aÃ±osNacimiento[0]);
const edad2 = calcularEdad(aÃ±osNacimiento[1]);
const edad3 = calcularEdad(aÃ±osNacimiento[2]);
const edades = [edad1, edad2, edad3];
const edades2 = [calcularEdad(aÃ±osNacimiento[0]), calcularEdad(aÃ±osNacimiento[1]), calcularEdad(aÃ±osNacimiento[2])];
```

TambiÃ©n  se  podrÃ­a  solucionar mediante iteraciones (for, while, foreach...) que veremos mÃ¡s adelante.

JS tiene muchos mÃ©todos asociados a arrays. Los veremos mÃ¡s adelante, pero cito aquÃ­ algunos:

```js
const edad4 = calcularEdad(1980);
edades.push(edad4);
console.log(edades);
```

**Array.unshift()** aÃ±ade al principio del array.
**Array.pop()** quita un elemento al final del array.
**Array.shift()**  quita  un elemento al principio del array
**Array.indexOf()** indica la posiciÃ³n del elemento
**Array.includes()** devuelve si el elemento existe o no


## Desafio 5
Resuelve el desafÃ­o 4 con arrrays.


# Objetos

Con arrays no  podemos dar nombre  a cada campo (array  asociativo en  php):
```js
const amigos = ["pepe", "juan", "lucas"];
const nombre='Fernando';
const fernando = [nombre, 'MartÃ­nez, 2022 - 1990, 'mecÃ¡nico', amigos];
console.log(fernando);
```

Con objetos podemos dar un nombre a cada campo y acceder a ellos mediante dos notaciones, . o []

```js
const amigos = ["pepe", "juan", "lucas"];
const Fernando = {
	nombre: 'Fernando',
  apelllido: "MartÃ­nez",
  profesiÃ³n: "mecÃ¡nico",
  aÃ±oNacimiento: 1980,
  amigos: amigos 
},
console.log(Fernando,  Fernando.apellido, Fernando['apellido']);
```

Siempre se usa la notaciÃ³n  con  punto. Es mÃ¡s clara  y corta, a no ser que necesitemos acceder a un  campo guardado en una variable:
```js
const campo = "apellido",
console.log(Fernando.campo,Fernando[campo]);
```

AÃ±adir campos es sencillo:
```js
Fernando.lugarTrabajo = 'Zaragoza';
Fernando['casado'] = false;
console.log(Fernando);
```

TambiÃ©n se puede aÃ±adir un campo  que sea una funciÃ³n:
```js
Fernando.calcularEdad = () => 2022 - this.aÃ±oNacimiento
```
Â¡Ojo!, ponemos this mejor que Fernando o que el valor  del aÃ±o de nacimiento, por DRY.


## Desafio 6

Haz el desafio 1 o 2 con objetos.


## Bucles


```js
for (let rep=1; rep<=30;  rep++) {
 // rep++ =  (rep = rep +1)
	console.log(`Esta es la repeticiÃ³n nÃºmero ${rep}`)
}
```

Break y continue  se usan para manejar las repeticiones:

```js
for (let rep=1; rep<=30;  rep++) {
 // rep++ =  (rep = rep +1)
if (rep%2 === 0) continue;
if (rep === 20) break;
	console.log(`Esta es la repeticiÃ³n nÃºmero ${rep}`)
}
```

Es habitual usarlos con Arrays

```js
const amigos = ["pepe", "juan", "lucas"];
for (let i=0, i<amigos.length, i++)  console.log(amigos[i]);
```

Otras opciones:

```js
let  rep=1;
while (rep <= 10)  {
	console.log(`Esta es la repeticiÃ³n nÃºmero ${rep}`)
	rep++;
}
```

```js
let dado = Math.trunc(Math.random() * 6) + 1;
while (dado !== 6) {
	console.log(`Has sacado un ${dado}`);
	dado = Math.trunc(Math.random() * 6) + 1;
	if (dado === 6) console.log('El bucle se va a terminar');
}
```

Otra opciÃ³n:   
```js
do {
	let dado = Math.trunc(Math.random() * 6) + 1;
	console.log(`Has sacado un ${dado}`);
	if (dado === 6) console.log('El bucle se va a terminar');
} while (dado !== 6)

```

El for es mÃ¡s adecuado para un nÃºmero fijo de iteraciones (por ejemplo, la longitud de  un array).